#=======================================================================================
#=======================================================================================
[üìåüõ†Ô∏è FUNCIONES Y COMANDOS B√ÅSICOS EN POWERSHELL]:
# imprimir texto
Write-Output "Hola Mundo"
# o m√°s directo:
"Hola Mundo"

# leer entrada del usuario
$nombre = Read-Host -Prompt "Nombre"
Write-Output "Hola $nombre"

# variables
$var = "texto"
$var

# condicional if (archivo)
if (Test-Path -Path "C:\Windows\System32\drivers\etc\hosts") {
    "Archivo existe"
}

# if / else (directorio)
if (Test-Path -Path "C:\Temp" -PathType Container) {
    "Directorio tmp existe"
} else {
    "No existe"
}

# for cl√°sico (√≠ndice)
for ($i=1; $i -le 5; $i++) {
    "N√∫mero $i"
}

# foreach (colecci√≥n)
1..5 | ForEach-Object { "N√∫mero $_" }

# while
$count = 0
while ($count -lt 5) {
    $count
    $count++
}

# funciones (cmdlet-style)
function Mi-Funcion {
    param([string]$Mensaje = "Funci√≥n ejecutada")
    Write-Output $Mensaje
}
Mi-Funcion

# salir con c√≥digo (desde script)
exit 0

#=======================================================================================
#=======================================================================================
[üìåüõ†Ô∏è MANEJO DE ARCHIVOS Y DIRECTORIOS]:
# listar archivos (detalle)
Get-ChildItem -Path "C:\ruta" -Force

# crear directorio (recursivo)
New-Item -Path "C:\ruta\nuevo_dir" -ItemType Directory -Force

# copiar archivo
Copy-Item -Path "origen.txt" -Destination "destino.txt" -Force

# mover/renombrar
Move-Item -Path "archivo.txt" -Destination "C:\ruta\nuevo_nombre.txt" -Force

# eliminar archivo
Remove-Item -Path "archivo.txt" -Force

# eliminar directorio recursivo
Remove-Item -Path "C:\ruta\directorio" -Recurse -Force

# verificar existencia
if (Test-Path "archivo.txt") { "Existe" }

# leer archivo l√≠nea a l√≠nea
Get-Content -Path "archivo.txt" | ForEach-Object { $_ }

# leer como stream (m√°s eficiente en ficheros grandes)
Get-Content -Path "archivo.txt" -ReadCount 0 | ForEach-Object { $_ }

#=======================================================================================
#=======================================================================================
[üìåüõ†Ô∏è MANEJO DE PERMISOS Y USUARIOS (Windows / PowerShell)]:
# ver ACL (permiso)
Get-Acl -Path "archivo.txt" | Format-List

# modificar ACL (ejemplo: dar FullControl a DOMAIN\User)
$acl = Get-Acl "archivo.txt"
$rule = New-Object System.Security.AccessControl.FileSystemAccessRule("DOMAIN\User","FullControl","Allow")
$acl.AddAccessRule($rule)
Set-Acl -Path "archivo.txt" -AclObject $acl

# cambiar propietario
takeown /F "archivo.txt"     # console util
# o con .NET:
$owner = [System.Security.Principal.NTAccount]"DOMAIN\User"
$acl.SetOwner($owner)
Set-Acl -Path "archivo.txt" -AclObject $acl

# crear usuario local (Admin rights required)
New-LocalUser -Name "nuevo_usuario" -NoPassword -Description "Cuenta temporal"
Add-LocalGroupMember -Group "Users" -Member "nuevo_usuario"
# establecer contrase√±a (securestring)
$pw = Read-Host -AsSecureString "Nueva contrase√±a"
Set-LocalUser -Name "nuevo_usuario" -Password $pw

# ejecutar comando como otro usuario (credenciales)
$cred = Get-Credential
Start-Process -FilePath "powershell.exe" -Credential $cred

#=======================================================================================
#=======================================================================================
[üìåüõ†Ô∏è REDES Y CONECTIVIDAD]:
# ver IP y configuraci√≥n de red
Get-NetIPAddress
Get-NetIPConfiguration

# hacer ping
Test-Connection -ComputerName google.com -Count 4

# escanear puerto (simple)
# usa .NET TcpClient para un solo puerto:
$ip = "192.168.1.1"; $port = 22
$tcp = New-Object System.Net.Sockets.TcpClient
try {
  $tcp.Connect($ip,$port); "Abierto"
} catch { "Cerrado" } finally { $tcp.Close() }

# usar nmap si est√° instalado (mejor opci√≥n para escaneo)
nmap -sT 192.168.1.1

# consultar DNS
Resolve-DnsName example.com

# prueba HTTP / APIs (GET, POST)
Invoke-RestMethod -Method Get -Uri "https://api.example.com/data"
Invoke-RestMethod -Method Post -Uri "https://api.example.com/post" -Body @{ param = 'valor' } 

# simple socket TCP (telnet equivalente)
# (Use Test-NetConnection para probe TCP)
Test-NetConnection -ComputerName example.com -Port 80

#=======================================================================================
#=======================================================================================
[üìåüõ†Ô∏è CONTROL DE PROCESOS]:
# listar procesos
Get-Process

# buscar proceso por nombre
Get-Process -Name "notepad" -ErrorAction SilentlyContinue

# matar proceso por PID
Stop-Process -Id 1234 -Force

# matar por nombre
Stop-Process -Name "notepad" -Force

# ver uso CPU/Memory detallado
Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 10

# procesos en tiempo real (actualiza)
Get-Process | Out-GridView -Title "Procesos"   # GUI quick filter

#=======================================================================================
#=======================================================================================
[üìåüõ†Ô∏è MANEJO DE LOGS]:
# ver logs de Windows Event (√∫ltimos 50 errores del System)
Get-WinEvent -LogName System -MaxEvents 50 | Where-Object { $_.LevelDisplayName -eq "Error" }

# ver logs en tiempo real (suscripci√≥n)
$subscription = Register-WmiEvent -Query "Select * from __InstanceCreationEvent Within 1 Where TargetInstance ISA 'Win32_NTLogEvent'" -Action { $event = $Event.SourceEventArgs.NewEvent; $event.TargetInstance.Message }

# buscar texto en archivos de log
Select-String -Path "C:\logs\*.log" -Pattern "error" -SimpleMatch

# rotar logs simple: renombrar y crear nuevo
Move-Item -Path "C:\logs\app.log" -Destination "C:\logs\app.log.old" -Force
# enviar se√±al depende de la app: por ejemplo, reiniciar servicio
Restart-Service -Name "MiServicio"

#=======================================================================================
#=======================================================================================
[üìåüõ†Ô∏è SEGURIDAD Y BUENAS PR√ÅCTICAS EN POWERSHELL]:
# validaci√≥n / escapado para evitar inyecci√≥n:
# evita construir comandos con strings; usa par√°metros y objetos
# ejemplo seguro con Invoke-Command:
Invoke-Command -ComputerName $host -ScriptBlock { Param($p) Get-ChildItem -Path $p } -ArgumentList "C:\Windows"

# comprobar disponibilidad de cmdlet o ejecutable
if (Get-Command curl -ErrorAction SilentlyContinue) { "curl instalado" } else { "no instalado" }

# restringir ejecuci√≥n de scripts (pol√≠tica)
Get-ExecutionPolicy
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine   # requiere privilegios

# manejo de secrets (no imprimir)
$secret = Read-Host -AsSecureString "Introduce secreto"
# convertir a plain solo si es estrictamente necesario y con control
# [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($sec))

# trap / finally para limpiar
try {
    # tarea
} catch {
    Write-Error $_
} finally {
    Write-Output "Limpiando..."
}

# firma de scripts para integridad (mejor pr√°ctica en infra)
Set-AuthenticodeSignature -FilePath ".\script.ps1" -Certificate (Get-ChildItem Cert:\CurrentUser\My -CodeSigningCert)

#=======================================================================================
#=======================================================================================
[üìåüõ†Ô∏è TAREAS PROGRAMADAS ¬∑ EJECUCI√ìN REMOTA Y AUTOMATIZACI√ìN]:
# ejecutar comando remoto (WinRM / PowerShell Remoting) - habilitar previamente
Enable-PSRemoting -Force
Invoke-Command -ComputerName host -ScriptBlock { Get-ChildItem C:\inetpub\wwwroot }

# copiar archivo remoto (Copy-Item sobre session)
$s = New-PSSession -ComputerName host
Copy-Item -Path "archivo.txt" -Destination "C:\ruta\" -ToSession $s
Remove-PSSession $s

# programar tarea (Task Scheduler)
$action = New-ScheduledTaskAction -Execute "PowerShell.exe" -Argument "-File C:\ruta\script.ps1"
$trigger = New-ScheduledTaskTrigger -Daily -At 2am
Register-ScheduledTask -TaskName "MiScriptDiario" -Action $action -Trigger $trigger -User "SYSTEM"

# ejemplo con SSH (Windows OpenSSH)
ssh usuario@host "Get-ChildItem C:\"
scp archivo.txt usuario@host:C:\ruta\

#=======================================================================================
#=======================================================================================
[üìåüõ†Ô∏è LIBRER√çAS / M√ìDULOS √öTILES EN POWERSHELL]:
- PowerShellGet / PSGallery: instalar m√≥dulos (Install-Module)
- Powershell Remoting (WinRM): administraci√≥n remota segura
- PnP.PowerShell: para SharePoint/Office365
- AzureAD / Az: gesti√≥n cloud (Azure)
- PSReadLine: edici√≥n avanzada shell
- Invoke-IR / PowerSploit (solo para auditor√≠as autorizadas): post-exploit / pentesting (usar con √©tica/legalidad)
- Nmap / Wireshark / Sysinternals (PsExec, PsList, PsKill...): herramientas externas que complementan PowerShell
